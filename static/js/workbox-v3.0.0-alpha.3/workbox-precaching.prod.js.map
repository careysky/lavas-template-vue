{"version":3,"file":"workbox-precaching.prod.js","sources":["packages/workbox-precaching/_version.mjs","packages/workbox-precaching/models/PrecacheEntry.mjs","packages/workbox-precaching/models/PrecachedDetailsModel.mjs","packages/workbox-precaching/utils/cleanRedirect.mjs","packages/workbox-precaching/controllers/PrecacheController.mjs","packages/workbox-precaching/_default.mjs","packages/workbox-precaching/browser.mjs"],"sourcesContent":["try{self.workbox.v['workbox:precaching:3.0.0-alpha.3']=1;}catch(e){} // eslint-disable-line","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\n/**\n * Used as a consistent way of referencing a URL to precache.\n *\n * @private\n * @memberof module:workbox-precaching\n */\nexport default class PrecacheEntry {\n/**\n * This class ensures all cache list entries are consistent and\n * adds cache busting if required.\n *\n * @param {*} originalInput\n * @param {string} url\n * @param {string} revision\n * @param {boolean} shouldCacheBust\n */\n  constructor(originalInput, url, revision, shouldCacheBust) {\n    this._originalInput = originalInput;\n    this._entryId = url;\n    this._revision = revision;\n    const requestAsCacheKey = new Request(url);\n    this._cacheRequest = requestAsCacheKey;\n    this._networkRequest = shouldCacheBust ?\n      this._cacheBustRequest(requestAsCacheKey) : requestAsCacheKey;\n  }\n\n  /**\n   * This method will either use Request.cache option OR append a cache\n   * busting parameter to the URL.\n   *\n   * @param {Request} request The request to cache bust\n   * @return {Request} A cachebusted Request\n   *\n   * @private\n   */\n  _cacheBustRequest(request) {\n    let url = request.url;\n    const requestOptions = {};\n    if ('cache' in Request.prototype) {\n      // Make use of the Request cache mode where we can.\n      // Reload skips the HTTP cache for outgoing requests and updates\n      // the cache with the returned response.\n      requestOptions.cache = 'reload';\n    } else {\n      const parsedURL = new URL(url, location);\n\n      // This is done so the minifier can mangle 'global.encodeURIComponent'\n      const _encodeURIComponent = encodeURIComponent;\n\n      parsedURL.search += (parsedURL.search ? '&' : '') +\n        _encodeURIComponent(`_workbox-cache-bust`) + '=' +\n        _encodeURIComponent(this._revision);\n      url = parsedURL.toString();\n    }\n\n    return new Request(url, requestOptions);\n  }\n}\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport '../_version.mjs';\n\n// Allows minifier to mangle this name\nconst REVISON_IDB_FIELD = 'revision';\nconst URL_IDB_FIELD = 'url';\nconst DB_STORE_NAME = 'precached-details-models';\n/**\n * This model will track the relevant information of entries that\n * are cached and their matching revision details.\n *\n * @private\n */\nclass PrecachedDetailsModel {\n  /**\n   * Construct a new model for a specific cache.\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._db = new DBWrapper(`workbox-precaching`, 2, {\n      onupgradeneeded: (evt) => {\n        if (evt.oldVersion < 2) {\n          try {\n            evt.target.result.deleteObjectStore('workbox-precaching');\n          } catch (err) {\n            // NOOP\n          }\n        }\n        evt.target.result.createObjectStore(DB_STORE_NAME);\n      },\n    });\n  }\n\n  /**\n   * Check if an entry is already cached. Returns false if\n   * the entry isn't cached or the revision has changed.\n   *\n   * @param {PrecacheEntry} precacheEntry\n   * @return {boolean}\n   *\n   * @private\n   */\n  async _isEntryCached(precacheEntry) {\n    const revisionDetails = await this._getRevision(precacheEntry._entryId);\n    if (revisionDetails !== precacheEntry._revision) {\n      return false;\n    }\n\n    const openCache = await caches.open(this._cacheName);\n    const cachedResponse = await openCache.match(precacheEntry._cacheRequest);\n    return !!cachedResponse;\n  }\n\n  /**\n   * @return {Promise<Array>}\n   *\n   * @private\n   */\n  async _getAllEntries() {\n    return await this._db.getAllMatching(DB_STORE_NAME, {\n      includeKeys: true,\n    });\n  }\n\n  /**\n   * Get the current revision details.\n   *\n   * @param {Object} entryId\n   * @return {Promise<string|null>}\n   *\n   * @private\n   */\n  async _getRevision(entryId) {\n    const data = await this._db.get(DB_STORE_NAME, entryId);\n    return data ? data[REVISON_IDB_FIELD] : null;\n  }\n\n  /**\n   * Add an entry to the details model.\n   *\n   * @param {PrecacheEntry} precacheEntry\n   *\n   * @private\n   */\n  async _addEntry(precacheEntry) {\n    await this._db.put(\n      DB_STORE_NAME,\n      {\n        [REVISON_IDB_FIELD]: precacheEntry._revision,\n        [URL_IDB_FIELD]: precacheEntry._cacheRequest.url,\n      },\n      precacheEntry._entryId\n    );\n  }\n\n  /**\n   * Delete entry from details model.\n   *\n   * @param {string} entryId\n   *\n   * @private\n   */\n  async _deleteEntry(entryId) {\n    await this._db.delete(DB_STORE_NAME, entryId);\n  }\n}\n\nexport default PrecachedDetailsModel;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport '../_version.mjs';\n\n/**\n * @param {Response} response\n * @return {Response}\n *\n * @private\n * @memberof module:workbox-precachig\n */\nconst cleanRedirect = async (response) => {\n  const clonedResponse = response.clone();\n\n  // Not all browsers support the Response.body stream, so fall back\n  // to reading the entire body into memory as a blob.\n  const bodyPromise = 'body' in clonedResponse ?\n    Promise.resolve(clonedResponse.body) :\n    clonedResponse.blob();\n\n  const body = await bodyPromise;\n\n  // new Response() is happy when passed either a stream or a Blob.\n  return new Response(body, ['headers', 'status', 'statusText'].map((key) => {\n      return clonedResponse[key];\n    })\n  );\n};\n\nexport default cleanRedirect;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {fetchWrapper} from 'workbox-core/_private/fetchWrapper.mjs';\nimport {cacheWrapper} from 'workbox-core/_private/cacheWrapper.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport PrecacheEntry from '../models/PrecacheEntry.mjs';\nimport PrecachedDetailsModel from '../models/PrecachedDetailsModel.mjs';\nimport showWarningsIfNeeded from '../utils/showWarningsIfNeeded.mjs';\nimport printInstallDetails from '../utils/printInstallDetails.mjs';\nimport printCleanupDetails from '../utils/printCleanupDetails.mjs';\nimport cleanRedirect from '../utils/cleanRedirect.mjs';\nimport '../_version.mjs';\n\n/**\n * Performs efficient precaching of assets.\n *\n * @memberof workbox.precaching\n */\nclass PrecacheController {\n  /**\n   * Create a new PrecacheController.\n   *\n   * @param {string} cacheName\n   */\n  constructor(cacheName) {\n    this._cacheName = cacheNames.getPrecacheName(cacheName);\n    this._entriesToCacheMap = new Map();\n    this._precacheDetailsModel = new PrecachedDetailsModel(this._cacheName);\n  }\n\n  /**\n   * This method will add items to the precache list, removing duplicates\n   * and ensuring the information is valid.\n   *\n   * @param {\n   * Array<module:workbox-precaching.PrecacheController.PrecacheEntry|string>\n   * } entries Array of entries to\n   * precache.\n   */\n  addToCacheList(entries) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArray(entries, {\n        moduleName: 'workbox-precaching',\n        className: 'PrecacheController',\n        funcName: 'addToCacheList',\n        paramName: 'entries',\n      });\n    }\n\n    entries.map((userEntry) => {\n      this._addEntryToCacheList(\n        this._parseEntry(userEntry)\n      );\n    });\n  }\n\n  /**\n   * This method returns a precache entry.\n   *\n   * @private\n   * @param {string|Object} input\n   * @return {PrecacheEntry}\n   */\n  _parseEntry(input) {\n    switch (typeof input) {\n      case 'string': {\n        if (process.env.NODE_ENV !== 'production') {\n          if (input.length === 0) {\n            throw new WorkboxError(\n              'add-to-cache-list-unexpected-type', {\n                entry: input,\n              }\n            );\n          }\n        }\n\n        return new PrecacheEntry(input, input, input);\n      }\n      case 'object': {\n        if (process.env.NODE_ENV !== 'production') {\n          if (!input || !input.url) {\n            throw new WorkboxError(\n              'add-to-cache-list-unexpected-type', {\n                entry: input,\n              }\n            );\n          }\n        }\n\n        return new PrecacheEntry(\n          input, input.url, input.revision || input.url, !!input.revision);\n      }\n      default:\n        throw new WorkboxError('add-to-cache-list-unexpected-type', {\n          entry: input,\n        });\n    }\n  }\n\n  /**\n   * Adds an entry to the precache list, accounting for possible duplicates.\n   *\n   * @private\n   * @param {PrecacheEntry} entryToAdd\n   */\n  _addEntryToCacheList(entryToAdd) {\n    // Check if the entry is already part of the map\n    const existingEntry = this._entriesToCacheMap.get(entryToAdd._entryId);\n    if (!existingEntry) {\n      this._entriesToCacheMap.set(entryToAdd._entryId, entryToAdd);\n      return;\n    }\n\n    // Duplicates are fine, but make sure the revision information\n    // is the same.\n    if (existingEntry._revision !== entryToAdd._revision) {\n      throw new WorkboxError('add-to-cache-list-conflicting-entries', {\n        firstEntry: existingEntry._originalInput,\n        secondEntry: entryToAdd._originalInput,\n      });\n    }\n  }\n\n  /**\n   * Call this method from a service work install event to start\n   * precaching assets.\n   *\n   * @param {Object} options\n   * @param {boolean} options.suppressWarnings Suppress warning messages.\n   * @return {\n   * Promise<module:workbox-precaching.PrecacheController.InstallResult>}\n   */\n  async install(options = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (options.suppressWarnings !== true) {\n        showWarningsIfNeeded(this._entriesToCacheMap);\n      }\n    }\n\n    const entriesToPrecache = [];\n    const entriesAlreadyPrecached = [];\n\n    for (const precacheEntry of this._entriesToCacheMap.values()) {\n      if (await this._precacheDetailsModel._isEntryCached(precacheEntry)) {\n        entriesAlreadyPrecached.push(precacheEntry);\n      } else {\n        entriesToPrecache.push(precacheEntry);\n      }\n    }\n\n    // Wait for all requests to be cached.\n    await Promise.all(entriesToPrecache.map((precacheEntry) => {\n      return this._cacheEntry(precacheEntry);\n    }));\n\n    if (process.env.NODE_ENV !== 'production') {\n      printInstallDetails(entriesToPrecache, entriesAlreadyPrecached);\n    }\n\n    return {\n      updatedEntries: entriesToPrecache,\n      notUpdatedEntries: entriesAlreadyPrecached,\n    };\n  }\n\n  /**\n   * Requests the entry and saves it to the cache if the response\n   * is valid.\n   *\n   * @private\n   * @param {BaseCacheEntry} precacheEntry The entry to fetch and cache.\n   * @return {Promise<boolean>} Returns a promise that resolves once the entry\n   * has been fetched and cached or skipped if no update is needed. The\n   * promise resolves with true if the entry was cached / updated and\n   * false if the entry is already cached and up-to-date.\n   */\n  async _cacheEntry(precacheEntry) {\n    let response = await fetchWrapper.fetch(\n      precacheEntry._networkRequest,\n    );\n\n    if (response.redirected) {\n      response = await cleanRedirect(response);\n    }\n\n    await cacheWrapper.put(this._cacheName,\n      precacheEntry._cacheRequest, response);\n\n    await this._precacheDetailsModel._addEntry(precacheEntry);\n\n    return true;\n  }\n\n  /**\n   * Compare the URLs and determines which assets are no longer required\n   * in the cache.\n   *\n   * This should be called in the service worker activate event.\n   *\n   * @return {\n   * Promise<module:workbox-precaching.PrecacheController.CleanupResult>}\n   * Resolves with an object containing details of the deleted cache requests\n   * and precache revision details.\n   */\n  async cleanup() {\n    const expectedCacheUrls = [];\n    this._entriesToCacheMap.forEach((entry) => {\n      const fullUrl = new URL(entry._cacheRequest.url, location).toString();\n      expectedCacheUrls.push(fullUrl);\n    });\n\n    const [deletedCacheRequests, deletedRevisionDetails] = await Promise.all([\n      this._cleanupCache(expectedCacheUrls),\n      this._cleanupDetailsModel(expectedCacheUrls),\n    ]);\n\n    if (process.env.NODE_ENV !== 'production') {\n      printCleanupDetails(deletedCacheRequests, deletedRevisionDetails);\n    }\n\n    return {\n      deletedCacheRequests,\n      deletedRevisionDetails,\n    };\n  }\n\n  /**\n   * Goes through all the cache entries and removes any that are\n   * outdated.\n   *\n   * @private\n   * @param {Array<string>} expectedCacheUrls Array of URLs that are\n   * expected to be cached.\n   * @return {Promise<Array<string>>} Resolves to an array of URLs\n   * of cached requests that were deleted.\n   */\n  async _cleanupCache(expectedCacheUrls) {\n    if (!await caches.has(this._cacheName)) {\n      // Cache doesn't exist, so nothing to delete\n      return [];\n    }\n\n    const cache = await caches.open(this._cacheName);\n    const cachedRequests = await cache.keys();\n    const cachedRequestsToDelete = cachedRequests.filter((cachedRequest) => {\n      return !expectedCacheUrls.includes(\n        new URL(cachedRequest.url, location).toString()\n      );\n    });\n\n    await Promise.all(\n      cachedRequestsToDelete.map((cacheUrl) => cache.delete(cacheUrl))\n    );\n\n    return cachedRequestsToDelete.map((request) => request.url);\n  }\n\n  /**\n   * Goes through all entries in indexedDB and removes any that are outdated.\n   *\n   * @private\n   * @param {Array<string>} expectedCacheUrls Array of URLs that are\n   * expected to be cached.\n   * @return {Promise<Array<string>>} Resolves to an array of URLs removed\n   * from indexedDB.\n   */\n  async _cleanupDetailsModel(expectedCacheUrls) {\n    const revisionedEntries = await this._precacheDetailsModel._getAllEntries();\n    const detailsToDelete = revisionedEntries\n      .filter((entry) => {\n        const fullUrl = new URL(entry.value.url, location).toString();\n        return !expectedCacheUrls.includes(fullUrl);\n      });\n\n    await Promise.all(\n      detailsToDelete.map(\n        (entry) => this._precacheDetailsModel._deleteEntry(entry.primaryKey)\n      )\n    );\n    return detailsToDelete.map((entry) => {\n      return entry.value.url;\n    });\n  }\n\n  /**\n   * Returns an array of fully qualified URL's that will be precached.\n   *\n   * @return {Array<string>} An array of URLs.\n   */\n  getCachedUrls() {\n    return Array.from(this._entriesToCacheMap.keys())\n    .map((url) => new URL(url, location).href);\n  }\n}\n\nexport default PrecacheController;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\nimport PrecacheController from './controllers/PrecacheController.mjs';\nimport './_version.mjs';\n\nif (process.env.NODE_ENV !== 'production') {\n  assert.isSwEnv('workbox-precaching');\n}\n\nlet installActivateListenersAdded = false;\nlet fetchListenersAdded = false;\nlet suppressWarnings = false;\n\nconst cacheName = cacheNames.getPrecacheName();\nconst precacheController = new PrecacheController(cacheName);\n\nconst _removeIgnoreUrlParams = (origUrlObject, ignoreUrlParametersMatching) => {\n  // Exclude initial '?'\n  const searchString = origUrlObject.search.slice(1);\n\n  // Split into an array of 'key=value' strings\n  const keyValueStrings = searchString.split('&');\n  const keyValuePairs = keyValueStrings.map((keyValueString) => {\n    // Split each 'key=value' string into a [key, value] array\n    return keyValueString.split('=');\n  });\n  const filteredKeyValuesPairs = keyValuePairs.filter((keyValuePair) => {\n    return ignoreUrlParametersMatching\n      .every((ignoredRegex) => {\n        // Return true iff the key doesn't match any of the regexes.\n        return !ignoredRegex.test(keyValuePair[0]);\n      });\n  });\n  const filteredStrings = filteredKeyValuesPairs.map((keyValuePair) => {\n    // Join each [key, value] array into a 'key=value' string\n    return keyValuePair.join('=');\n  });\n\n  // Join the array of 'key=value' strings into a string with '&' in\n  // between each\n  const urlClone = new URL(origUrlObject);\n  urlClone.search = filteredStrings.join('&');\n  return urlClone;\n};\n\n/**\n * This function will take the request URL and manipulate it based on the\n * configuration options.\n *\n * @param {string} url\n * @param {Object} options\n * @return {string|null} Returns the URL in the cache that matches the request\n * if available, other null.\n *\n * @private\n */\nconst _getPrecachedUrl = (url, {\n  ignoreUrlParametersMatching = [/^utm_/],\n  directoryIndex = 'index.html',\n} = {}) => {\n  const urlObject = new URL(url, location);\n\n  // If we precache '/some-url' but the URL referenced from the browser\n  // is '/some-url#1234', the comparison won't work unless we normalise\n  // the URLS.\n  // See https://github.com/GoogleChrome/workbox/issues/488.\n  urlObject.hash = '';\n\n  const cachedUrls = precacheController.getCachedUrls();\n  if (cachedUrls.indexOf(urlObject.href) !== -1) {\n    // It's a perfect match\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Precaching found an exact URL match for ` +\n        getFriendlyURL(urlObject.toString()));\n    }\n    return urlObject.href;\n  }\n\n  let strippedUrl = _removeIgnoreUrlParams(\n    urlObject, ignoreUrlParametersMatching\n  );\n  if (cachedUrls.indexOf(strippedUrl.href) !== -1) {\n    if (process.env.NODE_ENV !== 'production') {\n      logger.debug(`Precaching found an exact URL match for stripped URL` +\n        getFriendlyURL(strippedUrl.toString()));\n    }\n    return strippedUrl.href;\n  }\n\n  if (directoryIndex && strippedUrl.pathname.endsWith('/')) {\n    strippedUrl.pathname += directoryIndex;\n    if (cachedUrls.indexOf(strippedUrl.href) !== -1) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching found an exact URL match with ` +\n          `'directoryIndex' ${getFriendlyURL(strippedUrl.toString())}`);\n      }\n      return strippedUrl.href;\n    }\n  }\n\n  return null;\n};\n\nconst moduleExports = {};\n\n/**\n * Add items to the precache list, removing any duplicates and\n * store the files in the\n * [\"precache cache\"]{@link module:workbox-core.cacheNames} when the service\n * worker installs.\n *\n * This method can be called multiple times.\n *\n * Please note: This method **will not** serve any of the cached files for you,\n * it only precaches files. To respond to a network request you call\n * [addRoute()]{@link module:workbox-precaching.addRoute}.\n *\n * If you have a single array of files to precache, you can just call\n * [precacheAndRoute()]{@link module:workbox-precaching.precacheAndRoute}.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n *\n * @alias workbox.precaching.precache\n */\nmoduleExports.precache = (entries) => {\n  precacheController.addToCacheList(entries);\n\n  if (installActivateListenersAdded || entries.length <= 0) {\n    return;\n  }\n\n  installActivateListenersAdded = true;\n  self.addEventListener('install', (event) => {\n    event.waitUntil(precacheController.install({suppressWarnings}));\n  });\n  self.addEventListener('activate', (event) => {\n    event.waitUntil(precacheController.cleanup());\n  });\n};\n\n/**\n * Add a `fetch` listener to the service worker that will\n * respond to\n * [network requests]{@link https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Custom_responses_to_requests}\n * with precached assets.\n *\n * Requests for assets that aren't precached, the `FetchEvent` will not be\n * responded to, allowing the event to fall through to other `fetch` event\n * listeners.\n *\n * @param {Object} options\n * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n * check cache entries for a URLs ending with '/' to see if there is a hit when\n * appending the `directoryIndex` value.\n * @param {Array<RegExp>} [options.ignoreUrlParametersMatching=[/^utm_/]] An\n * array of regex's to remove search params when looking for a cache match.\n *\n * @alias workbox.precaching.addRoute\n */\nmoduleExports.addRoute = (options) => {\n  if (fetchListenersAdded) {\n    // TODO: Throw error here.\n    return;\n  }\n\n  fetchListenersAdded = true;\n  self.addEventListener('fetch', (event) => {\n    const precachedUrl = _getPrecachedUrl(event.request.url, options);\n    if (!precachedUrl) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`Precaching found no match for ` +\n          getFriendlyURL(event.request.url));\n      }\n      return;\n    }\n\n    let responsePromise = caches.open(cacheName)\n    .then((cache) => {\n      return cache.match(precachedUrl);\n    });\n    if (process.env.NODE_ENV !== 'production') {\n      responsePromise = responsePromise.then((response) => {\n        // Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger.groupCollapsed(`Precaching is responding to: ` +\n          getFriendlyURL(event.request.url));\n        logger.log(`Serving the precached url: ${precachedUrl}`);\n\n        // The Request and Response objects contains a great deal of\n        // information, hide it under a group in case developers want to see it.\n        logger.groupCollapsed(`View request details here.`);\n        logger.unprefixed.log(event.request);\n        logger.groupEnd();\n\n        logger.groupCollapsed(`View response details here.`);\n        logger.unprefixed.log(response);\n        logger.groupEnd();\n\n        logger.groupEnd();\n        return response;\n      });\n    }\n    event.respondWith(responsePromise);\n  });\n};\n\n/**\n * This method will add entries to the precache list and add a route to\n * respond to fetch events.\n *\n * This is a convenience method that will call\n * [precache()]{@link module:workbox-precaching.precache} and\n * [addRoute()]{@link module:workbox-precaching.addRoute} in a single call.\n *\n * @param {Array<Object|string>} entries Array of entries to precache.\n * @param {Object} options See\n * [addRoute() options]{@link module:workbox-precaching.addRoute}.\n *\n * @alias workbox.precaching.precacheAndRoute\n */\nmoduleExports.precacheAndRoute = (entries, options) => {\n  moduleExports.precache(entries);\n  moduleExports.addRoute(options);\n};\n\n/**\n * Warnings will be logged if any of the precached assets are entered without\n * a `revision` property. This is extremely dangerous if the URL's aren't\n * revisioned. However, the warnings can be supressed with this method.\n *\n * @param {boolean} suppress\n *\n * @alias workbox.precaching.suppressWarnings\n */\nmoduleExports.suppressWarnings = (suppress) => {\n  suppressWarnings = suppress;\n};\n\nexport default moduleExports;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport * as publicAPI from './_public.mjs';\nimport defaultExport from './_default.mjs';\nimport './_version.mjs';\n\nconst finalExport = Object.assign(defaultExport, publicAPI);\n\nexport default finalExport;\n"],"names":["workbox","v","e","PrecacheEntry","originalInput","url","revision","shouldCacheBust","_originalInput","_entryId","_revision","requestAsCacheKey","Request","_cacheRequest","_networkRequest","this","_cacheBustRequest","request","requestOptions","prototype","cache","parsedURL","URL","location","_encodeURIComponent","encodeURIComponent","search","toString","DB_STORE_NAME","PrecachedDetailsModel","cacheName","_cacheName","cacheNames","getPrecacheName","_db","DBWrapper","evt","oldVersion","target","result","deleteObjectStore","err","createObjectStore","precacheEntry","_this","_getRevision","caches","open","match","_this2","getAllMatching","entryId","data","_this3","get","_this4","put","_this5","delete","cleanRedirect","response","clonedResponse","clone","body","Promise","resolve","blob","Response","map","key","PrecacheController","_entriesToCacheMap","Map","_precacheDetailsModel","entries","userEntry","_addEntryToCacheList","_parseEntry","input","WorkboxError","entryToAdd","existingEntry","set","options","entriesToPrecache","entriesAlreadyPrecached","values","_isEntryCached","push","all","_cacheEntry","fetchWrapper","fetch","redirected","cacheWrapper","_addEntry","expectedCacheUrls","forEach","entry","fullUrl","deletedCacheRequests","deletedRevisionDetails","_cleanupCache","_cleanupDetailsModel","has","cachedRequestsToDelete","keys","filter","cachedRequest","includes","cacheUrl","detailsToDelete","_getAllEntries","value","_deleteEntry","primaryKey","Array","from","href","installActivateListenersAdded","fetchListenersAdded","suppressWarnings","precacheController","moduleExports","precache","addToCacheList","length","addEventListener","event","waitUntil","install","cleanup","addRoute","precachedUrl","urlObject","hash","cachedUrls","getCachedUrls","indexOf","strippedUrl","origUrlObject","ignoreUrlParametersMatching","filteredStrings","slice","split","keyValueString","keyValuePair","every","ignoredRegex","test","join","urlClone","_removeIgnoreUrlParams","directoryIndex","pathname","endsWith","_getPrecachedUrl","responsePromise","then","respondWith","precacheAndRoute","suppress","Object","assign","defaultExport","publicAPI"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9ob21lL21hdHQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4zL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtcHJlY2FjaGluZy9fdmVyc2lvbi5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXByZWNhY2hpbmcvbW9kZWxzL1ByZWNhY2hlRW50cnkubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1wcmVjYWNoaW5nL21vZGVscy9QcmVjYWNoZWREZXRhaWxzTW9kZWwubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1wcmVjYWNoaW5nL3V0aWxzL2NsZWFuUmVkaXJlY3QubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1wcmVjYWNoaW5nL2NvbnRyb2xsZXJzL1ByZWNhY2hlQ29udHJvbGxlci5tanMiLCIvaG9tZS9tYXR0L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMy9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXByZWNhY2hpbmcvX2RlZmF1bHQubWpzIiwiL2hvbWUvbWF0dC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjMvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1wcmVjYWNoaW5nL2Jyb3dzZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbInRyeXtzZWxmLndvcmtib3gudlsnd29ya2JveDpwcmVjYWNoaW5nOjMuMC4wLWFscGhhLjMnXT0xO31jYXRjaChlKXt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUiLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogVXNlZCBhcyBhIGNvbnNpc3RlbnQgd2F5IG9mIHJlZmVyZW5jaW5nIGEgVVJMIHRvIHByZWNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyb2YgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVjYWNoZUVudHJ5IHtcbi8qKlxuICogVGhpcyBjbGFzcyBlbnN1cmVzIGFsbCBjYWNoZSBsaXN0IGVudHJpZXMgYXJlIGNvbnNpc3RlbnQgYW5kXG4gKiBhZGRzIGNhY2hlIGJ1c3RpbmcgaWYgcmVxdWlyZWQuXG4gKlxuICogQHBhcmFtIHsqfSBvcmlnaW5hbElucHV0XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gcmV2aXNpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQ2FjaGVCdXN0XG4gKi9cbiAgY29uc3RydWN0b3Iob3JpZ2luYWxJbnB1dCwgdXJsLCByZXZpc2lvbiwgc2hvdWxkQ2FjaGVCdXN0KSB7XG4gICAgdGhpcy5fb3JpZ2luYWxJbnB1dCA9IG9yaWdpbmFsSW5wdXQ7XG4gICAgdGhpcy5fZW50cnlJZCA9IHVybDtcbiAgICB0aGlzLl9yZXZpc2lvbiA9IHJldmlzaW9uO1xuICAgIGNvbnN0IHJlcXVlc3RBc0NhY2hlS2V5ID0gbmV3IFJlcXVlc3QodXJsKTtcbiAgICB0aGlzLl9jYWNoZVJlcXVlc3QgPSByZXF1ZXN0QXNDYWNoZUtleTtcbiAgICB0aGlzLl9uZXR3b3JrUmVxdWVzdCA9IHNob3VsZENhY2hlQnVzdCA/XG4gICAgICB0aGlzLl9jYWNoZUJ1c3RSZXF1ZXN0KHJlcXVlc3RBc0NhY2hlS2V5KSA6IHJlcXVlc3RBc0NhY2hlS2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgZWl0aGVyIHVzZSBSZXF1ZXN0LmNhY2hlIG9wdGlvbiBPUiBhcHBlbmQgYSBjYWNoZVxuICAgKiBidXN0aW5nIHBhcmFtZXRlciB0byB0aGUgVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlcXVlc3R9IHJlcXVlc3QgVGhlIHJlcXVlc3QgdG8gY2FjaGUgYnVzdFxuICAgKiBAcmV0dXJuIHtSZXF1ZXN0fSBBIGNhY2hlYnVzdGVkIFJlcXVlc3RcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jYWNoZUJ1c3RSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBsZXQgdXJsID0gcmVxdWVzdC51cmw7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7fTtcbiAgICBpZiAoJ2NhY2hlJyBpbiBSZXF1ZXN0LnByb3RvdHlwZSkge1xuICAgICAgLy8gTWFrZSB1c2Ugb2YgdGhlIFJlcXVlc3QgY2FjaGUgbW9kZSB3aGVyZSB3ZSBjYW4uXG4gICAgICAvLyBSZWxvYWQgc2tpcHMgdGhlIEhUVFAgY2FjaGUgZm9yIG91dGdvaW5nIHJlcXVlc3RzIGFuZCB1cGRhdGVzXG4gICAgICAvLyB0aGUgY2FjaGUgd2l0aCB0aGUgcmV0dXJuZWQgcmVzcG9uc2UuXG4gICAgICByZXF1ZXN0T3B0aW9ucy5jYWNoZSA9ICdyZWxvYWQnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24pO1xuXG4gICAgICAvLyBUaGlzIGlzIGRvbmUgc28gdGhlIG1pbmlmaWVyIGNhbiBtYW5nbGUgJ2dsb2JhbC5lbmNvZGVVUklDb21wb25lbnQnXG4gICAgICBjb25zdCBfZW5jb2RlVVJJQ29tcG9uZW50ID0gZW5jb2RlVVJJQ29tcG9uZW50O1xuXG4gICAgICBwYXJzZWRVUkwuc2VhcmNoICs9IChwYXJzZWRVUkwuc2VhcmNoID8gJyYnIDogJycpICtcbiAgICAgICAgX2VuY29kZVVSSUNvbXBvbmVudChgX3dvcmtib3gtY2FjaGUtYnVzdGApICsgJz0nICtcbiAgICAgICAgX2VuY29kZVVSSUNvbXBvbmVudCh0aGlzLl9yZXZpc2lvbik7XG4gICAgICB1cmwgPSBwYXJzZWRVUkwudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLCByZXF1ZXN0T3B0aW9ucyk7XG4gIH1cbn1cbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7REJXcmFwcGVyfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvREJXcmFwcGVyLm1qcyc7XG5pbXBvcnQge2NhY2hlTmFtZXN9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLm1qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbi8vIEFsbG93cyBtaW5pZmllciB0byBtYW5nbGUgdGhpcyBuYW1lXG5jb25zdCBSRVZJU09OX0lEQl9GSUVMRCA9ICdyZXZpc2lvbic7XG5jb25zdCBVUkxfSURCX0ZJRUxEID0gJ3VybCc7XG5jb25zdCBEQl9TVE9SRV9OQU1FID0gJ3ByZWNhY2hlZC1kZXRhaWxzLW1vZGVscyc7XG4vKipcbiAqIFRoaXMgbW9kZWwgd2lsbCB0cmFjayB0aGUgcmVsZXZhbnQgaW5mb3JtYXRpb24gb2YgZW50cmllcyB0aGF0XG4gKiBhcmUgY2FjaGVkIGFuZCB0aGVpciBtYXRjaGluZyByZXZpc2lvbiBkZXRhaWxzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFByZWNhY2hlZERldGFpbHNNb2RlbCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgbW9kZWwgZm9yIGEgc3BlY2lmaWMgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSkge1xuICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZXMuZ2V0UHJlY2FjaGVOYW1lKGNhY2hlTmFtZSk7XG4gICAgdGhpcy5fZGIgPSBuZXcgREJXcmFwcGVyKGB3b3JrYm94LXByZWNhY2hpbmdgLCAyLCB7XG4gICAgICBvbnVwZ3JhZGVuZWVkZWQ6IChldnQpID0+IHtcbiAgICAgICAgaWYgKGV2dC5vbGRWZXJzaW9uIDwgMikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldnQudGFyZ2V0LnJlc3VsdC5kZWxldGVPYmplY3RTdG9yZSgnd29ya2JveC1wcmVjYWNoaW5nJyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBOT09QXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV2dC50YXJnZXQucmVzdWx0LmNyZWF0ZU9iamVjdFN0b3JlKERCX1NUT1JFX05BTUUpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBlbnRyeSBpcyBhbHJlYWR5IGNhY2hlZC4gUmV0dXJucyBmYWxzZSBpZlxuICAgKiB0aGUgZW50cnkgaXNuJ3QgY2FjaGVkIG9yIHRoZSByZXZpc2lvbiBoYXMgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQcmVjYWNoZUVudHJ5fSBwcmVjYWNoZUVudHJ5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfaXNFbnRyeUNhY2hlZChwcmVjYWNoZUVudHJ5KSB7XG4gICAgY29uc3QgcmV2aXNpb25EZXRhaWxzID0gYXdhaXQgdGhpcy5fZ2V0UmV2aXNpb24ocHJlY2FjaGVFbnRyeS5fZW50cnlJZCk7XG4gICAgaWYgKHJldmlzaW9uRGV0YWlscyAhPT0gcHJlY2FjaGVFbnRyeS5fcmV2aXNpb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvcGVuQ2FjaGUgPSBhd2FpdCBjYWNoZXMub3Blbih0aGlzLl9jYWNoZU5hbWUpO1xuICAgIGNvbnN0IGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgb3BlbkNhY2hlLm1hdGNoKHByZWNhY2hlRW50cnkuX2NhY2hlUmVxdWVzdCk7XG4gICAgcmV0dXJuICEhY2FjaGVkUmVzcG9uc2U7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheT59XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfZ2V0QWxsRW50cmllcygpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5fZGIuZ2V0QWxsTWF0Y2hpbmcoREJfU1RPUkVfTkFNRSwge1xuICAgICAgaW5jbHVkZUtleXM6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjdXJyZW50IHJldmlzaW9uIGRldGFpbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeUlkXG4gICAqIEByZXR1cm4ge1Byb21pc2U8c3RyaW5nfG51bGw+fVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2dldFJldmlzaW9uKGVudHJ5SWQpIHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fZGIuZ2V0KERCX1NUT1JFX05BTUUsIGVudHJ5SWQpO1xuICAgIHJldHVybiBkYXRhID8gZGF0YVtSRVZJU09OX0lEQl9GSUVMRF0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlbnRyeSB0byB0aGUgZGV0YWlscyBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtQcmVjYWNoZUVudHJ5fSBwcmVjYWNoZUVudHJ5XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfYWRkRW50cnkocHJlY2FjaGVFbnRyeSkge1xuICAgIGF3YWl0IHRoaXMuX2RiLnB1dChcbiAgICAgIERCX1NUT1JFX05BTUUsXG4gICAgICB7XG4gICAgICAgIFtSRVZJU09OX0lEQl9GSUVMRF06IHByZWNhY2hlRW50cnkuX3JldmlzaW9uLFxuICAgICAgICBbVVJMX0lEQl9GSUVMRF06IHByZWNhY2hlRW50cnkuX2NhY2hlUmVxdWVzdC51cmwsXG4gICAgICB9LFxuICAgICAgcHJlY2FjaGVFbnRyeS5fZW50cnlJZFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGVudHJ5IGZyb20gZGV0YWlscyBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5SWRcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9kZWxldGVFbnRyeShlbnRyeUlkKSB7XG4gICAgYXdhaXQgdGhpcy5fZGIuZGVsZXRlKERCX1NUT1JFX05BTUUsIGVudHJ5SWQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByZWNhY2hlZERldGFpbHNNb2RlbDtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZVxuICogQHJldHVybiB7UmVzcG9uc2V9XG4gKlxuICogQHByaXZhdGVcbiAqIEBtZW1iZXJvZiBtb2R1bGU6d29ya2JveC1wcmVjYWNoaWdcbiAqL1xuY29uc3QgY2xlYW5SZWRpcmVjdCA9IGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG5cbiAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHRoZSBSZXNwb25zZS5ib2R5IHN0cmVhbSwgc28gZmFsbCBiYWNrXG4gIC8vIHRvIHJlYWRpbmcgdGhlIGVudGlyZSBib2R5IGludG8gbWVtb3J5IGFzIGEgYmxvYi5cbiAgY29uc3QgYm9keVByb21pc2UgPSAnYm9keScgaW4gY2xvbmVkUmVzcG9uc2UgP1xuICAgIFByb21pc2UucmVzb2x2ZShjbG9uZWRSZXNwb25zZS5ib2R5KSA6XG4gICAgY2xvbmVkUmVzcG9uc2UuYmxvYigpO1xuXG4gIGNvbnN0IGJvZHkgPSBhd2FpdCBib2R5UHJvbWlzZTtcblxuICAvLyBuZXcgUmVzcG9uc2UoKSBpcyBoYXBweSB3aGVuIHBhc3NlZCBlaXRoZXIgYSBzdHJlYW0gb3IgYSBCbG9iLlxuICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIFsnaGVhZGVycycsICdzdGF0dXMnLCAnc3RhdHVzVGV4dCddLm1hcCgoa2V5KSA9PiB7XG4gICAgICByZXR1cm4gY2xvbmVkUmVzcG9uc2Vba2V5XTtcbiAgICB9KVxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xlYW5SZWRpcmVjdDtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7Y2FjaGVOYW1lc30gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2NhY2hlTmFtZXMubWpzJztcbmltcG9ydCB7V29ya2JveEVycm9yfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvV29ya2JveEVycm9yLm1qcyc7XG5pbXBvcnQge2ZldGNoV3JhcHBlcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2ZldGNoV3JhcHBlci5tanMnO1xuaW1wb3J0IHtjYWNoZVdyYXBwZXJ9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZVdyYXBwZXIubWpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0Lm1qcyc7XG5pbXBvcnQgUHJlY2FjaGVFbnRyeSBmcm9tICcuLi9tb2RlbHMvUHJlY2FjaGVFbnRyeS5tanMnO1xuaW1wb3J0IFByZWNhY2hlZERldGFpbHNNb2RlbCBmcm9tICcuLi9tb2RlbHMvUHJlY2FjaGVkRGV0YWlsc01vZGVsLm1qcyc7XG5pbXBvcnQgc2hvd1dhcm5pbmdzSWZOZWVkZWQgZnJvbSAnLi4vdXRpbHMvc2hvd1dhcm5pbmdzSWZOZWVkZWQubWpzJztcbmltcG9ydCBwcmludEluc3RhbGxEZXRhaWxzIGZyb20gJy4uL3V0aWxzL3ByaW50SW5zdGFsbERldGFpbHMubWpzJztcbmltcG9ydCBwcmludENsZWFudXBEZXRhaWxzIGZyb20gJy4uL3V0aWxzL3ByaW50Q2xlYW51cERldGFpbHMubWpzJztcbmltcG9ydCBjbGVhblJlZGlyZWN0IGZyb20gJy4uL3V0aWxzL2NsZWFuUmVkaXJlY3QubWpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBQZXJmb3JtcyBlZmZpY2llbnQgcHJlY2FjaGluZyBvZiBhc3NldHMuXG4gKlxuICogQG1lbWJlcm9mIHdvcmtib3gucHJlY2FjaGluZ1xuICovXG5jbGFzcyBQcmVjYWNoZUNvbnRyb2xsZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFByZWNhY2hlQ29udHJvbGxlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FjaGVOYW1lKSB7XG4gICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUoY2FjaGVOYW1lKTtcbiAgICB0aGlzLl9lbnRyaWVzVG9DYWNoZU1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9wcmVjYWNoZURldGFpbHNNb2RlbCA9IG5ldyBQcmVjYWNoZWREZXRhaWxzTW9kZWwodGhpcy5fY2FjaGVOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICAgKiBhbmQgZW5zdXJpbmcgdGhlIGluZm9ybWF0aW9uIGlzIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1xuICAgKiBBcnJheTxtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlQ29udHJvbGxlci5QcmVjYWNoZUVudHJ5fHN0cmluZz5cbiAgICogfSBlbnRyaWVzIEFycmF5IG9mIGVudHJpZXMgdG9cbiAgICogcHJlY2FjaGUuXG4gICAqL1xuICBhZGRUb0NhY2hlTGlzdChlbnRyaWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydC5pc0FycmF5KGVudHJpZXMsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcHJlY2FjaGluZycsXG4gICAgICAgIGNsYXNzTmFtZTogJ1ByZWNhY2hlQ29udHJvbGxlcicsXG4gICAgICAgIGZ1bmNOYW1lOiAnYWRkVG9DYWNoZUxpc3QnLFxuICAgICAgICBwYXJhbU5hbWU6ICdlbnRyaWVzJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVudHJpZXMubWFwKCh1c2VyRW50cnkpID0+IHtcbiAgICAgIHRoaXMuX2FkZEVudHJ5VG9DYWNoZUxpc3QoXG4gICAgICAgIHRoaXMuX3BhcnNlRW50cnkodXNlckVudHJ5KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgcHJlY2FjaGUgZW50cnkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gaW5wdXRcbiAgICogQHJldHVybiB7UHJlY2FjaGVFbnRyeX1cbiAgICovXG4gIF9wYXJzZUVudHJ5KGlucHV0KSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5wdXQpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKFxuICAgICAgICAgICAgICAnYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJywge1xuICAgICAgICAgICAgICAgIGVudHJ5OiBpbnB1dCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByZWNhY2hlRW50cnkoaW5wdXQsIGlucHV0LCBpbnB1dCk7XG4gICAgICB9XG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKCFpbnB1dCB8fCAhaW5wdXQudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKFxuICAgICAgICAgICAgICAnYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlJywge1xuICAgICAgICAgICAgICAgIGVudHJ5OiBpbnB1dCxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByZWNhY2hlRW50cnkoXG4gICAgICAgICAgaW5wdXQsIGlucHV0LnVybCwgaW5wdXQucmV2aXNpb24gfHwgaW5wdXQudXJsLCAhIWlucHV0LnJldmlzaW9uKTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2FkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZScsIHtcbiAgICAgICAgICBlbnRyeTogaW5wdXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVudHJ5IHRvIHRoZSBwcmVjYWNoZSBsaXN0LCBhY2NvdW50aW5nIGZvciBwb3NzaWJsZSBkdXBsaWNhdGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1ByZWNhY2hlRW50cnl9IGVudHJ5VG9BZGRcbiAgICovXG4gIF9hZGRFbnRyeVRvQ2FjaGVMaXN0KGVudHJ5VG9BZGQpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgZW50cnkgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtYXBcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gdGhpcy5fZW50cmllc1RvQ2FjaGVNYXAuZ2V0KGVudHJ5VG9BZGQuX2VudHJ5SWQpO1xuICAgIGlmICghZXhpc3RpbmdFbnRyeSkge1xuICAgICAgdGhpcy5fZW50cmllc1RvQ2FjaGVNYXAuc2V0KGVudHJ5VG9BZGQuX2VudHJ5SWQsIGVudHJ5VG9BZGQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIER1cGxpY2F0ZXMgYXJlIGZpbmUsIGJ1dCBtYWtlIHN1cmUgdGhlIHJldmlzaW9uIGluZm9ybWF0aW9uXG4gICAgLy8gaXMgdGhlIHNhbWUuXG4gICAgaWYgKGV4aXN0aW5nRW50cnkuX3JldmlzaW9uICE9PSBlbnRyeVRvQWRkLl9yZXZpc2lvbikge1xuICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctZW50cmllcycsIHtcbiAgICAgICAgZmlyc3RFbnRyeTogZXhpc3RpbmdFbnRyeS5fb3JpZ2luYWxJbnB1dCxcbiAgICAgICAgc2Vjb25kRW50cnk6IGVudHJ5VG9BZGQuX29yaWdpbmFsSW5wdXQsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCBmcm9tIGEgc2VydmljZSB3b3JrIGluc3RhbGwgZXZlbnQgdG8gc3RhcnRcbiAgICogcHJlY2FjaGluZyBhc3NldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5zdXBwcmVzc1dhcm5pbmdzIFN1cHByZXNzIHdhcm5pbmcgbWVzc2FnZXMuXG4gICAqIEByZXR1cm4ge1xuICAgKiBQcm9taXNlPG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLkluc3RhbGxSZXN1bHQ+fVxuICAgKi9cbiAgYXN5bmMgaW5zdGFsbChvcHRpb25zID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3VwcHJlc3NXYXJuaW5ncyAhPT0gdHJ1ZSkge1xuICAgICAgICBzaG93V2FybmluZ3NJZk5lZWRlZCh0aGlzLl9lbnRyaWVzVG9DYWNoZU1hcCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZW50cmllc1RvUHJlY2FjaGUgPSBbXTtcbiAgICBjb25zdCBlbnRyaWVzQWxyZWFkeVByZWNhY2hlZCA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBwcmVjYWNoZUVudHJ5IG9mIHRoaXMuX2VudHJpZXNUb0NhY2hlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5fcHJlY2FjaGVEZXRhaWxzTW9kZWwuX2lzRW50cnlDYWNoZWQocHJlY2FjaGVFbnRyeSkpIHtcbiAgICAgICAgZW50cmllc0FscmVhZHlQcmVjYWNoZWQucHVzaChwcmVjYWNoZUVudHJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJpZXNUb1ByZWNhY2hlLnB1c2gocHJlY2FjaGVFbnRyeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2FpdCBmb3IgYWxsIHJlcXVlc3RzIHRvIGJlIGNhY2hlZC5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChlbnRyaWVzVG9QcmVjYWNoZS5tYXAoKHByZWNhY2hlRW50cnkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZUVudHJ5KHByZWNhY2hlRW50cnkpO1xuICAgIH0pKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcmludEluc3RhbGxEZXRhaWxzKGVudHJpZXNUb1ByZWNhY2hlLCBlbnRyaWVzQWxyZWFkeVByZWNhY2hlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVwZGF0ZWRFbnRyaWVzOiBlbnRyaWVzVG9QcmVjYWNoZSxcbiAgICAgIG5vdFVwZGF0ZWRFbnRyaWVzOiBlbnRyaWVzQWxyZWFkeVByZWNhY2hlZCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIHRoZSBlbnRyeSBhbmQgc2F2ZXMgaXQgdG8gdGhlIGNhY2hlIGlmIHRoZSByZXNwb25zZVxuICAgKiBpcyB2YWxpZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCYXNlQ2FjaGVFbnRyeX0gcHJlY2FjaGVFbnRyeSBUaGUgZW50cnkgdG8gZmV0Y2ggYW5kIGNhY2hlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPGJvb2xlYW4+fSBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGVudHJ5XG4gICAqIGhhcyBiZWVuIGZldGNoZWQgYW5kIGNhY2hlZCBvciBza2lwcGVkIGlmIG5vIHVwZGF0ZSBpcyBuZWVkZWQuIFRoZVxuICAgKiBwcm9taXNlIHJlc29sdmVzIHdpdGggdHJ1ZSBpZiB0aGUgZW50cnkgd2FzIGNhY2hlZCAvIHVwZGF0ZWQgYW5kXG4gICAqIGZhbHNlIGlmIHRoZSBlbnRyeSBpcyBhbHJlYWR5IGNhY2hlZCBhbmQgdXAtdG8tZGF0ZS5cbiAgICovXG4gIGFzeW5jIF9jYWNoZUVudHJ5KHByZWNhY2hlRW50cnkpIHtcbiAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdyYXBwZXIuZmV0Y2goXG4gICAgICBwcmVjYWNoZUVudHJ5Ll9uZXR3b3JrUmVxdWVzdCxcbiAgICApO1xuXG4gICAgaWYgKHJlc3BvbnNlLnJlZGlyZWN0ZWQpIHtcbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2xlYW5SZWRpcmVjdChyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgYXdhaXQgY2FjaGVXcmFwcGVyLnB1dCh0aGlzLl9jYWNoZU5hbWUsXG4gICAgICBwcmVjYWNoZUVudHJ5Ll9jYWNoZVJlcXVlc3QsIHJlc3BvbnNlKTtcblxuICAgIGF3YWl0IHRoaXMuX3ByZWNhY2hlRGV0YWlsc01vZGVsLl9hZGRFbnRyeShwcmVjYWNoZUVudHJ5KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmUgdGhlIFVSTHMgYW5kIGRldGVybWluZXMgd2hpY2ggYXNzZXRzIGFyZSBubyBsb25nZXIgcmVxdWlyZWRcbiAgICogaW4gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW4gdGhlIHNlcnZpY2Ugd29ya2VyIGFjdGl2YXRlIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtcbiAgICogUHJvbWlzZTxtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLlByZWNhY2hlQ29udHJvbGxlci5DbGVhbnVwUmVzdWx0Pn1cbiAgICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIG9mIHRoZSBkZWxldGVkIGNhY2hlIHJlcXVlc3RzXG4gICAqIGFuZCBwcmVjYWNoZSByZXZpc2lvbiBkZXRhaWxzLlxuICAgKi9cbiAgYXN5bmMgY2xlYW51cCgpIHtcbiAgICBjb25zdCBleHBlY3RlZENhY2hlVXJscyA9IFtdO1xuICAgIHRoaXMuX2VudHJpZXNUb0NhY2hlTWFwLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBmdWxsVXJsID0gbmV3IFVSTChlbnRyeS5fY2FjaGVSZXF1ZXN0LnVybCwgbG9jYXRpb24pLnRvU3RyaW5nKCk7XG4gICAgICBleHBlY3RlZENhY2hlVXJscy5wdXNoKGZ1bGxVcmwpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgW2RlbGV0ZWRDYWNoZVJlcXVlc3RzLCBkZWxldGVkUmV2aXNpb25EZXRhaWxzXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX2NsZWFudXBDYWNoZShleHBlY3RlZENhY2hlVXJscyksXG4gICAgICB0aGlzLl9jbGVhbnVwRGV0YWlsc01vZGVsKGV4cGVjdGVkQ2FjaGVVcmxzKSxcbiAgICBdKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRDYWNoZVJlcXVlc3RzLCBkZWxldGVkUmV2aXNpb25EZXRhaWxzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGVsZXRlZENhY2hlUmVxdWVzdHMsXG4gICAgICBkZWxldGVkUmV2aXNpb25EZXRhaWxzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR29lcyB0aHJvdWdoIGFsbCB0aGUgY2FjaGUgZW50cmllcyBhbmQgcmVtb3ZlcyBhbnkgdGhhdCBhcmVcbiAgICogb3V0ZGF0ZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gZXhwZWN0ZWRDYWNoZVVybHMgQXJyYXkgb2YgVVJMcyB0aGF0IGFyZVxuICAgKiBleHBlY3RlZCB0byBiZSBjYWNoZWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59IFJlc29sdmVzIHRvIGFuIGFycmF5IG9mIFVSTHNcbiAgICogb2YgY2FjaGVkIHJlcXVlc3RzIHRoYXQgd2VyZSBkZWxldGVkLlxuICAgKi9cbiAgYXN5bmMgX2NsZWFudXBDYWNoZShleHBlY3RlZENhY2hlVXJscykge1xuICAgIGlmICghYXdhaXQgY2FjaGVzLmhhcyh0aGlzLl9jYWNoZU5hbWUpKSB7XG4gICAgICAvLyBDYWNoZSBkb2Vzbid0IGV4aXN0LCBzbyBub3RoaW5nIHRvIGRlbGV0ZVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgY2FjaGVzLm9wZW4odGhpcy5fY2FjaGVOYW1lKTtcbiAgICBjb25zdCBjYWNoZWRSZXF1ZXN0cyA9IGF3YWl0IGNhY2hlLmtleXMoKTtcbiAgICBjb25zdCBjYWNoZWRSZXF1ZXN0c1RvRGVsZXRlID0gY2FjaGVkUmVxdWVzdHMuZmlsdGVyKChjYWNoZWRSZXF1ZXN0KSA9PiB7XG4gICAgICByZXR1cm4gIWV4cGVjdGVkQ2FjaGVVcmxzLmluY2x1ZGVzKFxuICAgICAgICBuZXcgVVJMKGNhY2hlZFJlcXVlc3QudXJsLCBsb2NhdGlvbikudG9TdHJpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY2FjaGVkUmVxdWVzdHNUb0RlbGV0ZS5tYXAoKGNhY2hlVXJsKSA9PiBjYWNoZS5kZWxldGUoY2FjaGVVcmwpKVxuICAgICk7XG5cbiAgICByZXR1cm4gY2FjaGVkUmVxdWVzdHNUb0RlbGV0ZS5tYXAoKHJlcXVlc3QpID0+IHJlcXVlc3QudXJsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHb2VzIHRocm91Z2ggYWxsIGVudHJpZXMgaW4gaW5kZXhlZERCIGFuZCByZW1vdmVzIGFueSB0aGF0IGFyZSBvdXRkYXRlZC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBleHBlY3RlZENhY2hlVXJscyBBcnJheSBvZiBVUkxzIHRoYXQgYXJlXG4gICAqIGV4cGVjdGVkIHRvIGJlIGNhY2hlZC5cbiAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gUmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgVVJMcyByZW1vdmVkXG4gICAqIGZyb20gaW5kZXhlZERCLlxuICAgKi9cbiAgYXN5bmMgX2NsZWFudXBEZXRhaWxzTW9kZWwoZXhwZWN0ZWRDYWNoZVVybHMpIHtcbiAgICBjb25zdCByZXZpc2lvbmVkRW50cmllcyA9IGF3YWl0IHRoaXMuX3ByZWNhY2hlRGV0YWlsc01vZGVsLl9nZXRBbGxFbnRyaWVzKCk7XG4gICAgY29uc3QgZGV0YWlsc1RvRGVsZXRlID0gcmV2aXNpb25lZEVudHJpZXNcbiAgICAgIC5maWx0ZXIoKGVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IGZ1bGxVcmwgPSBuZXcgVVJMKGVudHJ5LnZhbHVlLnVybCwgbG9jYXRpb24pLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiAhZXhwZWN0ZWRDYWNoZVVybHMuaW5jbHVkZXMoZnVsbFVybCk7XG4gICAgICB9KTtcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgZGV0YWlsc1RvRGVsZXRlLm1hcChcbiAgICAgICAgKGVudHJ5KSA9PiB0aGlzLl9wcmVjYWNoZURldGFpbHNNb2RlbC5fZGVsZXRlRW50cnkoZW50cnkucHJpbWFyeUtleSlcbiAgICAgIClcbiAgICApO1xuICAgIHJldHVybiBkZXRhaWxzVG9EZWxldGUubWFwKChlbnRyeSkgPT4ge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlLnVybDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5IHF1YWxpZmllZCBVUkwncyB0aGF0IHdpbGwgYmUgcHJlY2FjaGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fSBBbiBhcnJheSBvZiBVUkxzLlxuICAgKi9cbiAgZ2V0Q2FjaGVkVXJscygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9lbnRyaWVzVG9DYWNoZU1hcC5rZXlzKCkpXG4gICAgLm1hcCgodXJsKSA9PiBuZXcgVVJMKHVybCwgbG9jYXRpb24pLmhyZWYpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByZWNhY2hlQ29udHJvbGxlcjtcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0Lm1qcyc7XG5pbXBvcnQge2NhY2hlTmFtZXN9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLm1qcyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5tanMnO1xuaW1wb3J0IHtnZXRGcmllbmRseVVSTH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLm1qcyc7XG5pbXBvcnQgUHJlY2FjaGVDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvUHJlY2FjaGVDb250cm9sbGVyLm1qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24ubWpzJztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgYXNzZXJ0LmlzU3dFbnYoJ3dvcmtib3gtcHJlY2FjaGluZycpO1xufVxuXG5sZXQgaW5zdGFsbEFjdGl2YXRlTGlzdGVuZXJzQWRkZWQgPSBmYWxzZTtcbmxldCBmZXRjaExpc3RlbmVyc0FkZGVkID0gZmFsc2U7XG5sZXQgc3VwcHJlc3NXYXJuaW5ncyA9IGZhbHNlO1xuXG5jb25zdCBjYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZSgpO1xuY29uc3QgcHJlY2FjaGVDb250cm9sbGVyID0gbmV3IFByZWNhY2hlQ29udHJvbGxlcihjYWNoZU5hbWUpO1xuXG5jb25zdCBfcmVtb3ZlSWdub3JlVXJsUGFyYW1zID0gKG9yaWdVcmxPYmplY3QsIGlnbm9yZVVybFBhcmFtZXRlcnNNYXRjaGluZykgPT4ge1xuICAvLyBFeGNsdWRlIGluaXRpYWwgJz8nXG4gIGNvbnN0IHNlYXJjaFN0cmluZyA9IG9yaWdVcmxPYmplY3Quc2VhcmNoLnNsaWNlKDEpO1xuXG4gIC8vIFNwbGl0IGludG8gYW4gYXJyYXkgb2YgJ2tleT12YWx1ZScgc3RyaW5nc1xuICBjb25zdCBrZXlWYWx1ZVN0cmluZ3MgPSBzZWFyY2hTdHJpbmcuc3BsaXQoJyYnKTtcbiAgY29uc3Qga2V5VmFsdWVQYWlycyA9IGtleVZhbHVlU3RyaW5ncy5tYXAoKGtleVZhbHVlU3RyaW5nKSA9PiB7XG4gICAgLy8gU3BsaXQgZWFjaCAna2V5PXZhbHVlJyBzdHJpbmcgaW50byBhIFtrZXksIHZhbHVlXSBhcnJheVxuICAgIHJldHVybiBrZXlWYWx1ZVN0cmluZy5zcGxpdCgnPScpO1xuICB9KTtcbiAgY29uc3QgZmlsdGVyZWRLZXlWYWx1ZXNQYWlycyA9IGtleVZhbHVlUGFpcnMuZmlsdGVyKChrZXlWYWx1ZVBhaXIpID0+IHtcbiAgICByZXR1cm4gaWdub3JlVXJsUGFyYW1ldGVyc01hdGNoaW5nXG4gICAgICAuZXZlcnkoKGlnbm9yZWRSZWdleCkgPT4ge1xuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZmYgdGhlIGtleSBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgcmVnZXhlcy5cbiAgICAgICAgcmV0dXJuICFpZ25vcmVkUmVnZXgudGVzdChrZXlWYWx1ZVBhaXJbMF0pO1xuICAgICAgfSk7XG4gIH0pO1xuICBjb25zdCBmaWx0ZXJlZFN0cmluZ3MgPSBmaWx0ZXJlZEtleVZhbHVlc1BhaXJzLm1hcCgoa2V5VmFsdWVQYWlyKSA9PiB7XG4gICAgLy8gSm9pbiBlYWNoIFtrZXksIHZhbHVlXSBhcnJheSBpbnRvIGEgJ2tleT12YWx1ZScgc3RyaW5nXG4gICAgcmV0dXJuIGtleVZhbHVlUGFpci5qb2luKCc9Jyk7XG4gIH0pO1xuXG4gIC8vIEpvaW4gdGhlIGFycmF5IG9mICdrZXk9dmFsdWUnIHN0cmluZ3MgaW50byBhIHN0cmluZyB3aXRoICcmJyBpblxuICAvLyBiZXR3ZWVuIGVhY2hcbiAgY29uc3QgdXJsQ2xvbmUgPSBuZXcgVVJMKG9yaWdVcmxPYmplY3QpO1xuICB1cmxDbG9uZS5zZWFyY2ggPSBmaWx0ZXJlZFN0cmluZ3Muam9pbignJicpO1xuICByZXR1cm4gdXJsQ2xvbmU7XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0YWtlIHRoZSByZXF1ZXN0IFVSTCBhbmQgbWFuaXB1bGF0ZSBpdCBiYXNlZCBvbiB0aGVcbiAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7c3RyaW5nfG51bGx9IFJldHVybnMgdGhlIFVSTCBpbiB0aGUgY2FjaGUgdGhhdCBtYXRjaGVzIHRoZSByZXF1ZXN0XG4gKiBpZiBhdmFpbGFibGUsIG90aGVyIG51bGwuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgX2dldFByZWNhY2hlZFVybCA9ICh1cmwsIHtcbiAgaWdub3JlVXJsUGFyYW1ldGVyc01hdGNoaW5nID0gWy9edXRtXy9dLFxuICBkaXJlY3RvcnlJbmRleCA9ICdpbmRleC5odG1sJyxcbn0gPSB7fSkgPT4ge1xuICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24pO1xuXG4gIC8vIElmIHdlIHByZWNhY2hlICcvc29tZS11cmwnIGJ1dCB0aGUgVVJMIHJlZmVyZW5jZWQgZnJvbSB0aGUgYnJvd3NlclxuICAvLyBpcyAnL3NvbWUtdXJsIzEyMzQnLCB0aGUgY29tcGFyaXNvbiB3b24ndCB3b3JrIHVubGVzcyB3ZSBub3JtYWxpc2VcbiAgLy8gdGhlIFVSTFMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dvcmtib3gvaXNzdWVzLzQ4OC5cbiAgdXJsT2JqZWN0Lmhhc2ggPSAnJztcblxuICBjb25zdCBjYWNoZWRVcmxzID0gcHJlY2FjaGVDb250cm9sbGVyLmdldENhY2hlZFVybHMoKTtcbiAgaWYgKGNhY2hlZFVybHMuaW5kZXhPZih1cmxPYmplY3QuaHJlZikgIT09IC0xKSB7XG4gICAgLy8gSXQncyBhIHBlcmZlY3QgbWF0Y2hcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBQcmVjYWNoaW5nIGZvdW5kIGFuIGV4YWN0IFVSTCBtYXRjaCBmb3IgYCArXG4gICAgICAgIGdldEZyaWVuZGx5VVJMKHVybE9iamVjdC50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIHJldHVybiB1cmxPYmplY3QuaHJlZjtcbiAgfVxuXG4gIGxldCBzdHJpcHBlZFVybCA9IF9yZW1vdmVJZ25vcmVVcmxQYXJhbXMoXG4gICAgdXJsT2JqZWN0LCBpZ25vcmVVcmxQYXJhbWV0ZXJzTWF0Y2hpbmdcbiAgKTtcbiAgaWYgKGNhY2hlZFVybHMuaW5kZXhPZihzdHJpcHBlZFVybC5ocmVmKSAhPT0gLTEpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgbG9nZ2VyLmRlYnVnKGBQcmVjYWNoaW5nIGZvdW5kIGFuIGV4YWN0IFVSTCBtYXRjaCBmb3Igc3RyaXBwZWQgVVJMYCArXG4gICAgICAgIGdldEZyaWVuZGx5VVJMKHN0cmlwcGVkVXJsLnRvU3RyaW5nKCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmlwcGVkVXJsLmhyZWY7XG4gIH1cblxuICBpZiAoZGlyZWN0b3J5SW5kZXggJiYgc3RyaXBwZWRVcmwucGF0aG5hbWUuZW5kc1dpdGgoJy8nKSkge1xuICAgIHN0cmlwcGVkVXJsLnBhdGhuYW1lICs9IGRpcmVjdG9yeUluZGV4O1xuICAgIGlmIChjYWNoZWRVcmxzLmluZGV4T2Yoc3RyaXBwZWRVcmwuaHJlZikgIT09IC0xKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIuZGVidWcoYFByZWNhY2hpbmcgZm91bmQgYW4gZXhhY3QgVVJMIG1hdGNoIHdpdGggYCArXG4gICAgICAgICAgYCdkaXJlY3RvcnlJbmRleCcgJHtnZXRGcmllbmRseVVSTChzdHJpcHBlZFVybC50b1N0cmluZygpKX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpcHBlZFVybC5ocmVmO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgbW9kdWxlRXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIEFkZCBpdGVtcyB0byB0aGUgcHJlY2FjaGUgbGlzdCwgcmVtb3ZpbmcgYW55IGR1cGxpY2F0ZXMgYW5kXG4gKiBzdG9yZSB0aGUgZmlsZXMgaW4gdGhlXG4gKiBbXCJwcmVjYWNoZSBjYWNoZVwiXXtAbGluayBtb2R1bGU6d29ya2JveC1jb3JlLmNhY2hlTmFtZXN9IHdoZW4gdGhlIHNlcnZpY2VcbiAqIHdvcmtlciBpbnN0YWxscy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBsZWFzZSBub3RlOiBUaGlzIG1ldGhvZCAqKndpbGwgbm90Kiogc2VydmUgYW55IG9mIHRoZSBjYWNoZWQgZmlsZXMgZm9yIHlvdSxcbiAqIGl0IG9ubHkgcHJlY2FjaGVzIGZpbGVzLiBUbyByZXNwb25kIHRvIGEgbmV0d29yayByZXF1ZXN0IHlvdSBjYWxsXG4gKiBbYWRkUm91dGUoKV17QGxpbmsgbW9kdWxlOndvcmtib3gtcHJlY2FjaGluZy5hZGRSb3V0ZX0uXG4gKlxuICogSWYgeW91IGhhdmUgYSBzaW5nbGUgYXJyYXkgb2YgZmlsZXMgdG8gcHJlY2FjaGUsIHlvdSBjYW4ganVzdCBjYWxsXG4gKiBbcHJlY2FjaGVBbmRSb3V0ZSgpXXtAbGluayBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLnByZWNhY2hlQW5kUm91dGV9LlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0fHN0cmluZz59IGVudHJpZXMgQXJyYXkgb2YgZW50cmllcyB0byBwcmVjYWNoZS5cbiAqXG4gKiBAYWxpYXMgd29ya2JveC5wcmVjYWNoaW5nLnByZWNhY2hlXG4gKi9cbm1vZHVsZUV4cG9ydHMucHJlY2FjaGUgPSAoZW50cmllcykgPT4ge1xuICBwcmVjYWNoZUNvbnRyb2xsZXIuYWRkVG9DYWNoZUxpc3QoZW50cmllcyk7XG5cbiAgaWYgKGluc3RhbGxBY3RpdmF0ZUxpc3RlbmVyc0FkZGVkIHx8IGVudHJpZXMubGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpbnN0YWxsQWN0aXZhdGVMaXN0ZW5lcnNBZGRlZCA9IHRydWU7XG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignaW5zdGFsbCcsIChldmVudCkgPT4ge1xuICAgIGV2ZW50LndhaXRVbnRpbChwcmVjYWNoZUNvbnRyb2xsZXIuaW5zdGFsbCh7c3VwcHJlc3NXYXJuaW5nc30pKTtcbiAgfSk7XG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYWN0aXZhdGUnLCAoZXZlbnQpID0+IHtcbiAgICBldmVudC53YWl0VW50aWwocHJlY2FjaGVDb250cm9sbGVyLmNsZWFudXAoKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgYSBgZmV0Y2hgIGxpc3RlbmVyIHRvIHRoZSBzZXJ2aWNlIHdvcmtlciB0aGF0IHdpbGxcbiAqIHJlc3BvbmQgdG9cbiAqIFtuZXR3b3JrIHJlcXVlc3RzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU2VydmljZV9Xb3JrZXJfQVBJL1VzaW5nX1NlcnZpY2VfV29ya2VycyNDdXN0b21fcmVzcG9uc2VzX3RvX3JlcXVlc3RzfVxuICogd2l0aCBwcmVjYWNoZWQgYXNzZXRzLlxuICpcbiAqIFJlcXVlc3RzIGZvciBhc3NldHMgdGhhdCBhcmVuJ3QgcHJlY2FjaGVkLCB0aGUgYEZldGNoRXZlbnRgIHdpbGwgbm90IGJlXG4gKiByZXNwb25kZWQgdG8sIGFsbG93aW5nIHRoZSBldmVudCB0byBmYWxsIHRocm91Z2ggdG8gb3RoZXIgYGZldGNoYCBldmVudFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZGlyZWN0b3J5SW5kZXg9aW5kZXguaHRtbF0gVGhlIGBkaXJlY3RvcnlJbmRleGAgd2lsbFxuICogY2hlY2sgY2FjaGUgZW50cmllcyBmb3IgYSBVUkxzIGVuZGluZyB3aXRoICcvJyB0byBzZWUgaWYgdGhlcmUgaXMgYSBoaXQgd2hlblxuICogYXBwZW5kaW5nIHRoZSBgZGlyZWN0b3J5SW5kZXhgIHZhbHVlLlxuICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSBbb3B0aW9ucy5pZ25vcmVVcmxQYXJhbWV0ZXJzTWF0Y2hpbmc9Wy9edXRtXy9dXSBBblxuICogYXJyYXkgb2YgcmVnZXgncyB0byByZW1vdmUgc2VhcmNoIHBhcmFtcyB3aGVuIGxvb2tpbmcgZm9yIGEgY2FjaGUgbWF0Y2guXG4gKlxuICogQGFsaWFzIHdvcmtib3gucHJlY2FjaGluZy5hZGRSb3V0ZVxuICovXG5tb2R1bGVFeHBvcnRzLmFkZFJvdXRlID0gKG9wdGlvbnMpID0+IHtcbiAgaWYgKGZldGNoTGlzdGVuZXJzQWRkZWQpIHtcbiAgICAvLyBUT0RPOiBUaHJvdyBlcnJvciBoZXJlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGZldGNoTGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZldGNoJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgcHJlY2FjaGVkVXJsID0gX2dldFByZWNhY2hlZFVybChldmVudC5yZXF1ZXN0LnVybCwgb3B0aW9ucyk7XG4gICAgaWYgKCFwcmVjYWNoZWRVcmwpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgUHJlY2FjaGluZyBmb3VuZCBubyBtYXRjaCBmb3IgYCArXG4gICAgICAgICAgZ2V0RnJpZW5kbHlVUkwoZXZlbnQucmVxdWVzdC51cmwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVzcG9uc2VQcm9taXNlID0gY2FjaGVzLm9wZW4oY2FjaGVOYW1lKVxuICAgIC50aGVuKChjYWNoZSkgPT4ge1xuICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKHByZWNhY2hlZFVybCk7XG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAvLyBXb3JrYm94IGlzIGdvaW5nIHRvIGhhbmRsZSB0aGUgcm91dGUuXG4gICAgICAgIC8vIHByaW50IHRoZSByb3V0aW5nIGRldGFpbHMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUHJlY2FjaGluZyBpcyByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICBnZXRGcmllbmRseVVSTChldmVudC5yZXF1ZXN0LnVybCkpO1xuICAgICAgICBsb2dnZXIubG9nKGBTZXJ2aW5nIHRoZSBwcmVjYWNoZWQgdXJsOiAke3ByZWNhY2hlZFVybH1gKTtcblxuICAgICAgICAvLyBUaGUgUmVxdWVzdCBhbmQgUmVzcG9uc2Ugb2JqZWN0cyBjb250YWlucyBhIGdyZWF0IGRlYWwgb2ZcbiAgICAgICAgLy8gaW5mb3JtYXRpb24sIGhpZGUgaXQgdW5kZXIgYSBncm91cCBpbiBjYXNlIGRldmVsb3BlcnMgd2FudCB0byBzZWUgaXQuXG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXF1ZXN0IGRldGFpbHMgaGVyZS5gKTtcbiAgICAgICAgbG9nZ2VyLnVucHJlZml4ZWQubG9nKGV2ZW50LnJlcXVlc3QpO1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcblxuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFZpZXcgcmVzcG9uc2UgZGV0YWlscyBoZXJlLmApO1xuICAgICAgICBsb2dnZXIudW5wcmVmaXhlZC5sb2cocmVzcG9uc2UpO1xuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcblxuICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50LnJlc3BvbmRXaXRoKHJlc3BvbnNlUHJvbWlzZSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBlbnRyaWVzIHRvIHRoZSBwcmVjYWNoZSBsaXN0IGFuZCBhZGQgYSByb3V0ZSB0b1xuICogcmVzcG9uZCB0byBmZXRjaCBldmVudHMuXG4gKlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHdpbGwgY2FsbFxuICogW3ByZWNhY2hlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcucHJlY2FjaGV9IGFuZFxuICogW2FkZFJvdXRlKClde0BsaW5rIG1vZHVsZTp3b3JrYm94LXByZWNhY2hpbmcuYWRkUm91dGV9IGluIGEgc2luZ2xlIGNhbGwuXG4gKlxuICogQHBhcmFtIHtBcnJheTxPYmplY3R8c3RyaW5nPn0gZW50cmllcyBBcnJheSBvZiBlbnRyaWVzIHRvIHByZWNhY2hlLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU2VlXG4gKiBbYWRkUm91dGUoKSBvcHRpb25zXXtAbGluayBtb2R1bGU6d29ya2JveC1wcmVjYWNoaW5nLmFkZFJvdXRlfS5cbiAqXG4gKiBAYWxpYXMgd29ya2JveC5wcmVjYWNoaW5nLnByZWNhY2hlQW5kUm91dGVcbiAqL1xubW9kdWxlRXhwb3J0cy5wcmVjYWNoZUFuZFJvdXRlID0gKGVudHJpZXMsIG9wdGlvbnMpID0+IHtcbiAgbW9kdWxlRXhwb3J0cy5wcmVjYWNoZShlbnRyaWVzKTtcbiAgbW9kdWxlRXhwb3J0cy5hZGRSb3V0ZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogV2FybmluZ3Mgd2lsbCBiZSBsb2dnZWQgaWYgYW55IG9mIHRoZSBwcmVjYWNoZWQgYXNzZXRzIGFyZSBlbnRlcmVkIHdpdGhvdXRcbiAqIGEgYHJldmlzaW9uYCBwcm9wZXJ0eS4gVGhpcyBpcyBleHRyZW1lbHkgZGFuZ2Vyb3VzIGlmIHRoZSBVUkwncyBhcmVuJ3RcbiAqIHJldmlzaW9uZWQuIEhvd2V2ZXIsIHRoZSB3YXJuaW5ncyBjYW4gYmUgc3VwcmVzc2VkIHdpdGggdGhpcyBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBzdXBwcmVzc1xuICpcbiAqIEBhbGlhcyB3b3JrYm94LnByZWNhY2hpbmcuc3VwcHJlc3NXYXJuaW5nc1xuICovXG5tb2R1bGVFeHBvcnRzLnN1cHByZXNzV2FybmluZ3MgPSAoc3VwcHJlc3MpID0+IHtcbiAgc3VwcHJlc3NXYXJuaW5ncyA9IHN1cHByZXNzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgbW9kdWxlRXhwb3J0cztcbiIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAqIGFzIHB1YmxpY0FQSSBmcm9tICcuL19wdWJsaWMubWpzJztcbmltcG9ydCBkZWZhdWx0RXhwb3J0IGZyb20gJy4vX2RlZmF1bHQubWpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5tanMnO1xuXG5jb25zdCBmaW5hbEV4cG9ydCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdEV4cG9ydCwgcHVibGljQVBJKTtcblxuZXhwb3J0IGRlZmF1bHQgZmluYWxFeHBvcnQ7XG4iXSwibmFtZXMiOlsid29ya2JveCIsInYiLCJlIiwiUHJlY2FjaGVFbnRyeSIsIm9yaWdpbmFsSW5wdXQiLCJ1cmwiLCJyZXZpc2lvbiIsInNob3VsZENhY2hlQnVzdCIsIl9vcmlnaW5hbElucHV0IiwiX2VudHJ5SWQiLCJfcmV2aXNpb24iLCJyZXF1ZXN0QXNDYWNoZUtleSIsIlJlcXVlc3QiLCJfY2FjaGVSZXF1ZXN0IiwiX25ldHdvcmtSZXF1ZXN0IiwidGhpcyIsIl9jYWNoZUJ1c3RSZXF1ZXN0IiwicmVxdWVzdCIsInJlcXVlc3RPcHRpb25zIiwicHJvdG90eXBlIiwiY2FjaGUiLCJwYXJzZWRVUkwiLCJVUkwiLCJsb2NhdGlvbiIsIl9lbmNvZGVVUklDb21wb25lbnQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJzZWFyY2giLCJ0b1N0cmluZyIsIkRCX1NUT1JFX05BTUUiLCJQcmVjYWNoZWREZXRhaWxzTW9kZWwiLCJjYWNoZU5hbWUiLCJfY2FjaGVOYW1lIiwiY2FjaGVOYW1lcyIsImdldFByZWNhY2hlTmFtZSIsIl9kYiIsIkRCV3JhcHBlciIsImV2dCIsIm9sZFZlcnNpb24iLCJ0YXJnZXQiLCJyZXN1bHQiLCJkZWxldGVPYmplY3RTdG9yZSIsImVyciIsImNyZWF0ZU9iamVjdFN0b3JlIiwicHJlY2FjaGVFbnRyeSIsIl90aGlzIiwiX2dldFJldmlzaW9uIiwiY2FjaGVzIiwib3BlbiIsIm1hdGNoIiwiX3RoaXMyIiwiZ2V0QWxsTWF0Y2hpbmciLCJlbnRyeUlkIiwiZGF0YSIsIl90aGlzMyIsImdldCIsIl90aGlzNCIsInB1dCIsIl90aGlzNSIsImRlbGV0ZSIsImNsZWFuUmVkaXJlY3QiLCJyZXNwb25zZSIsImNsb25lZFJlc3BvbnNlIiwiY2xvbmUiLCJib2R5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJibG9iIiwiUmVzcG9uc2UiLCJtYXAiLCJrZXkiLCJQcmVjYWNoZUNvbnRyb2xsZXIiLCJfZW50cmllc1RvQ2FjaGVNYXAiLCJNYXAiLCJfcHJlY2FjaGVEZXRhaWxzTW9kZWwiLCJlbnRyaWVzIiwidXNlckVudHJ5IiwiX2FkZEVudHJ5VG9DYWNoZUxpc3QiLCJfcGFyc2VFbnRyeSIsImlucHV0IiwiV29ya2JveEVycm9yIiwiZW50cnlUb0FkZCIsImV4aXN0aW5nRW50cnkiLCJzZXQiLCJvcHRpb25zIiwiZW50cmllc1RvUHJlY2FjaGUiLCJlbnRyaWVzQWxyZWFkeVByZWNhY2hlZCIsInZhbHVlcyIsIl9pc0VudHJ5Q2FjaGVkIiwicHVzaCIsImFsbCIsIl9jYWNoZUVudHJ5IiwiZmV0Y2hXcmFwcGVyIiwiZmV0Y2giLCJyZWRpcmVjdGVkIiwiY2FjaGVXcmFwcGVyIiwiX2FkZEVudHJ5IiwiZXhwZWN0ZWRDYWNoZVVybHMiLCJmb3JFYWNoIiwiZW50cnkiLCJmdWxsVXJsIiwiZGVsZXRlZENhY2hlUmVxdWVzdHMiLCJkZWxldGVkUmV2aXNpb25EZXRhaWxzIiwiX2NsZWFudXBDYWNoZSIsIl9jbGVhbnVwRGV0YWlsc01vZGVsIiwiaGFzIiwiY2FjaGVkUmVxdWVzdHNUb0RlbGV0ZSIsImtleXMiLCJmaWx0ZXIiLCJjYWNoZWRSZXF1ZXN0IiwiaW5jbHVkZXMiLCJjYWNoZVVybCIsImRldGFpbHNUb0RlbGV0ZSIsIl9nZXRBbGxFbnRyaWVzIiwidmFsdWUiLCJfZGVsZXRlRW50cnkiLCJwcmltYXJ5S2V5IiwiQXJyYXkiLCJmcm9tIiwiaHJlZiIsImluc3RhbGxBY3RpdmF0ZUxpc3RlbmVyc0FkZGVkIiwiZmV0Y2hMaXN0ZW5lcnNBZGRlZCIsInN1cHByZXNzV2FybmluZ3MiLCJwcmVjYWNoZUNvbnRyb2xsZXIiLCJtb2R1bGVFeHBvcnRzIiwicHJlY2FjaGUiLCJhZGRUb0NhY2hlTGlzdCIsImxlbmd0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsIndhaXRVbnRpbCIsImluc3RhbGwiLCJjbGVhbnVwIiwiYWRkUm91dGUiLCJwcmVjYWNoZWRVcmwiLCJ1cmxPYmplY3QiLCJoYXNoIiwiY2FjaGVkVXJscyIsImdldENhY2hlZFVybHMiLCJpbmRleE9mIiwic3RyaXBwZWRVcmwiLCJvcmlnVXJsT2JqZWN0IiwiaWdub3JlVXJsUGFyYW1ldGVyc01hdGNoaW5nIiwiZmlsdGVyZWRTdHJpbmdzIiwic2xpY2UiLCJzcGxpdCIsImtleVZhbHVlU3RyaW5nIiwia2V5VmFsdWVQYWlyIiwiZXZlcnkiLCJpZ25vcmVkUmVnZXgiLCJ0ZXN0Iiwiam9pbiIsInVybENsb25lIiwiX3JlbW92ZUlnbm9yZVVybFBhcmFtcyIsImRpcmVjdG9yeUluZGV4IiwicGF0aG5hbWUiLCJlbmRzV2l0aCIsIl9nZXRQcmVjYWNoZWRVcmwiLCJyZXNwb25zZVByb21pc2UiLCJ0aGVuIiwicmVzcG9uZFdpdGgiLCJwcmVjYWNoZUFuZFJvdXRlIiwic3VwcHJlc3MiLCJPYmplY3QiLCJhc3NpZ24iLCJkZWZhdWx0RXhwb3J0IiwicHVibGljQVBJIl0sIm1hcHBpbmdzIjoidUZBQUEsU0FBU0EsUUFBUUMsRUFBRSxvQ0FBb0MsRUFBRyxNQUFNQyxVQ3dCM0NDLGNBVVBDLEVBQWVDLEVBQUtDLEVBQVVDLFFBQ25DQyxFQUFpQkosT0FDakJLLEVBQVdKLE9BQ1hLLEVBQVlKLFFBQ1hLLEVBQW9CLElBQUlDLFFBQVFQLFFBQ2pDUSxFQUFnQkYsT0FDaEJHLEVBQWtCUCxFQUNyQlEsS0FBS0MsRUFBa0JMLEdBQXFCQSxJQVk5Qk0sT0FDWlosRUFBTVksRUFBUVosVUFDWmEsUUFDRixVQUFXTixRQUFRTyxZQUlOQyxNQUFRLGFBQ2xCLE9BQ0NDLEVBQVksSUFBSUMsSUFBSWpCLEVBQUtrQixVQUd6QkMsRUFBc0JDLHFCQUVsQkMsU0FBV0wsRUFBVUssT0FBUyxJQUFNLElBQzVDRixFQUFxQix1QkFBd0IsSUFDN0NBLEVBQW9CVCxLQUFLTCxLQUNyQlcsRUFBVU0sa0JBR1gsSUFBSWYsUUFBUVAsRUFBS2EsSUNwRDVCLE1B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"}